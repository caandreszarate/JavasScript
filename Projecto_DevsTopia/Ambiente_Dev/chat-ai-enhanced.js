// Sistema de IA Avanzado para DevsTopia Chat
// An√°lisis de Sentimiento + Recomendaciones Inteligentes

// ===== AN√ÅLISIS DE SENTIMIENTO =====
function analyzeSentiment(message) {
    const urgentKeywords = ['urgente', 'emergencia', 'problema', 'error', 'cr√≠tico', 'falla', 'no funciona'];
    const positiveKeywords = ['gracias', 'excelente', 'perfecto', 'genial', 'me gusta', 'bueno', 'satisfecho'];
    const negativeKeywords = ['molesto', 'enojado', 'frustrado', 'malo', 'p√©simo', 'decepcionado', 'insatisfecho'];
    const neutralKeywords = ['informaci√≥n', 'consulta', 'pregunta', 'duda', 'ayuda'];
    
    const text = message.toLowerCase();
    let score = 0;
    let sentiment = 'neutral';
    
    // An√°lisis de palabras clave
    urgentKeywords.forEach(keyword => {
        if (text.includes(keyword)) score += 3;
    });
    
    positiveKeywords.forEach(keyword => {
        if (text.includes(keyword)) score += 1;
    });
    
    negativeKeywords.forEach(keyword => {
        if (text.includes(keyword)) score -= 2;
    });
    
    // Determinar sentimiento
    if (score >= 3) {
        sentiment = 'urgent';
    } else if (score >= 1) {
        sentiment = 'positive';
    } else if (score <= -2) {
        sentiment = 'negative';
    } else {
        sentiment = 'neutral';
    }
    
    return {
        sentiment: sentiment,
        score: score,
        confidence: Math.abs(score) / 3
    };
}

function getResponseBySentiment(sentiment, baseResponse) {
    const sentimentEmojis = {
        urgent: 'üö®',
        positive: 'üòä',
        negative: 'üòî',
        neutral: 'üí¨'
    };
    
    const sentimentPrefixes = {
        urgent: 'Entiendo la urgencia. ',
        positive: '¬°Me alegra saberlo! ',
        negative: 'Entiendo tu frustraci√≥n. ',
        neutral: ''
    };
    
    const sentimentSuffixes = {
        urgent: '\n\nüö® **Te conectar√© inmediatamente con un especialista.**',
        positive: '\n\n¬øHay algo m√°s en lo que pueda ayudarte?',
        negative: '\n\n¬øTe gustar√≠a hablar con un representante para resolver tu situaci√≥n?',
        neutral: ''
    };
    
    return `${sentimentEmojis[sentiment]} ${sentimentPrefixes[sentiment]}${baseResponse}${sentimentSuffixes[sentiment]}`;
}

// ===== SISTEMA DE RECOMENDACIONES INTELIGENTES =====
const SERVICE_RECOMMENDATIONS = {
    'ecommerce': {
        services: ['Desarrollo Web', 'Integraci√≥n de Pagos', 'SEO', 'Marketing Digital'],
        priority: 'high',
        estimatedCost: '$3000-8000 USD',
        timeline: '2-4 meses',
        description: 'Plataforma completa de comercio electr√≥nico'
    },
    'dashboard': {
        services: ['Desarrollo Web', 'An√°lisis de Datos', 'Cloud Services', 'API Integration'],
        priority: 'medium',
        estimatedCost: '$2000-5000 USD',
        timeline: '1-3 meses',
        description: 'Panel de control con visualizaci√≥n de datos'
    },
    'mobile': {
        services: ['Desarrollo M√≥vil', 'Backend API', 'Testing', 'App Store Deployment'],
        priority: 'high',
        estimatedCost: '$4000-12000 USD',
        timeline: '3-6 meses',
        description: 'Aplicaci√≥n m√≥vil nativa o h√≠brida'
    },
    'web': {
        services: ['Desarrollo Web', 'Responsive Design', 'SEO', 'Hosting'],
        priority: 'medium',
        estimatedCost: '$1500-5000 USD',
        timeline: '1-3 meses',
        description: 'Sitio web corporativo o aplicaci√≥n web'
    },
    'automation': {
        services: ['Automatizaci√≥n de Procesos', 'RPA', 'API Integration', 'Workflow Design'],
        priority: 'medium',
        estimatedCost: '$2500-7000 USD',
        timeline: '2-4 meses',
        description: 'Automatizaci√≥n de tareas empresariales'
    },
    'security': {
        services: ['Auditor√≠a de Seguridad', 'Penetration Testing', 'Security Implementation'],
        priority: 'high',
        estimatedCost: '$2000-8000 USD',
        timeline: '1-2 meses',
        description: 'Servicios de ciberseguridad'
    }
};

function getRecommendations(userMessage) {
    const message = userMessage.toLowerCase();
    const recommendations = [];
    
    for (const [keyword, data] of Object.entries(SERVICE_RECOMMENDATIONS)) {
        if (message.includes(keyword)) {
            recommendations.push({
                keyword: keyword,
                services: data.services,
                priority: data.priority,
                estimatedCost: data.estimatedCost,
                timeline: data.timeline,
                description: data.description
            });
        }
    }
    
    return recommendations;
}

function formatRecommendations(recommendations) {
    if (recommendations.length === 0) return '';
    
    let response = 'üéØ **Recomendaciones personalizadas:**\n\n';
    
    recommendations.forEach((rec, index) => {
        response += `**${index + 1}. ${rec.description}**\n`;
        response += `üìã Servicios: ${rec.services.join(', ')}\n`;
        response += `üí∞ Costo estimado: ${rec.estimatedCost}\n`;
        response += `‚è±Ô∏è Timeline: ${rec.timeline}\n`;
        response += `üéØ Prioridad: ${rec.priority === 'high' ? 'Alta' : 'Media'}\n\n`;
    });
    
    response += '¬øTe interesa alguna de estas opciones?';
    
    return response;
}

// ===== MEMORIA DE CONVERSACI√ìN =====
class ConversationMemory {
    constructor() {
        this.conversations = new Map();
        this.userPreferences = new Map();
    }
    
    addMessage(userId, message, response, sentiment) {
        if (!this.conversations.has(userId)) {
            this.conversations.set(userId, []);
        }
        
        this.conversations.get(userId).push({
            timestamp: Date.now(),
            userMessage: message,
            assistantResponse: response,
            sentiment: sentiment
        });
        
        // Actualizar preferencias del usuario
        this.updateUserPreferences(userId, message);
    }
    
    getContext(userId, maxMessages = 5) {
        const conversation = this.conversations.get(userId) || [];
        return conversation.slice(-maxMessages);
    }
    
    updateUserPreferences(userId, message) {
        if (!this.userPreferences.has(userId)) {
            this.userPreferences.set(userId, {
                preferredServices: [],
                budget: null,
                timeline: null,
                urgency: 'normal',
                interests: []
            });
        }
        
        const preferences = this.userPreferences.get(userId);
        const text = message.toLowerCase();
        
        // Detectar servicios de inter√©s
        Object.keys(SERVICE_RECOMMENDATIONS).forEach(service => {
            if (text.includes(service) && !preferences.interests.includes(service)) {
                preferences.interests.push(service);
            }
        });
        
        // Detectar presupuesto
        const budgetMatch = text.match(/(\d+)\s*(?:mil|k|usd|d√≥lares?)/i);
        if (budgetMatch) {
            preferences.budget = budgetMatch[1];
        }
        
        // Detectar timeline
        if (text.includes('urgente') || text.includes('r√°pido')) {
            preferences.urgency = 'high';
        }
        
        this.userPreferences.set(userId, preferences);
    }
    
    getUserPreferences(userId) {
        return this.userPreferences.get(userId) || {
            preferredServices: [],
            budget: null,
            timeline: null,
            urgency: 'normal',
            interests: []
        };
    }
    
    getPersonalizedGreeting(userId) {
        const preferences = this.getUserPreferences(userId);
        const context = this.getContext(userId, 3);
        
        if (context.length === 0) {
            return '¬°Hola! üëã Soy el asistente virtual de DevsTopia. ¬øEn qu√© puedo ayudarte hoy?';
        }
        
        if (preferences.interests.length > 0) {
            return `¬°Hola de nuevo! üëã Veo que te interesan nuestros servicios de ${preferences.interests.join(', ')}. ¬øEn qu√© m√°s puedo ayudarte?`;
        }
        
        return '¬°Hola de nuevo! üëã ¬øEn qu√© puedo ayudarte hoy?';
    }
}

// ===== SISTEMA DE ESCALAMIENTO INTELIGENTE =====
function shouldEscalateToHuman(sentiment, message, conversationHistory) {
    const urgentKeywords = ['urgente', 'emergencia', 'problema cr√≠tico', 'no funciona'];
    const complaintKeywords = ['queja', 'reclamo', 'insatisfecho', 'molesto'];
    
    const text = message.toLowerCase();
    
    // Condiciones para escalamiento
    if (sentiment === 'urgent') return true;
    if (complaintKeywords.some(keyword => text.includes(keyword))) return true;
    if (conversationHistory.length > 10) return true; // Conversaci√≥n muy larga
    
    return false;
}

function getEscalationMessage() {
    return `üö® **Detect√© que necesitas atenci√≥n especializada.**\n\n` +
           `Te conectar√© inmediatamente con un especialista de DevsTopia.\n\n` +
           `üìß Email: info@devstopia.com\n` +
           `üì± WhatsApp: +57 300 123 4567\n\n` +
           `Un representante se pondr√° en contacto contigo en menos de 30 minutos.`;
}

// ===== FUNCIONES PRINCIPALES =====
const conversationMemory = new ConversationMemory();

function processEnhancedResponse(userMessage, userId) {
    // An√°lisis de sentimiento
    const sentimentAnalysis = analyzeSentiment(userMessage);
    
    // Obtener contexto de conversaci√≥n
    const context = conversationMemory.getContext(userId);
    
    // Verificar si debe escalar a humano
    if (shouldEscalateToHuman(sentimentAnalysis.sentiment, userMessage, context)) {
        return {
            response: getEscalationMessage(),
            sentiment: sentimentAnalysis.sentiment,
            shouldEscalate: true,
            recommendations: []
        };
    }
    
    // Obtener recomendaciones
    const recommendations = getRecommendations(userMessage);
    
    // Procesar respuesta base (usar el sistema existente)
    const baseResponse = processAutoResponse(userMessage);
    
    // Aplicar sentimiento a la respuesta
    const enhancedResponse = getResponseBySentiment(sentimentAnalysis.sentiment, baseResponse);
    
    // Agregar recomendaciones si existen
    let finalResponse = enhancedResponse;
    if (recommendations.length > 0) {
        finalResponse += '\n\n' + formatRecommendations(recommendations);
    }
    
    // Guardar en memoria
    conversationMemory.addMessage(userId, userMessage, finalResponse, sentimentAnalysis.sentiment);
    
    return {
        response: finalResponse,
        sentiment: sentimentAnalysis.sentiment,
        shouldEscalate: false,
        recommendations: recommendations
    };
}

// ===== EXPORTAR FUNCIONES =====
window.processEnhancedResponse = processEnhancedResponse;
window.analyzeSentiment = analyzeSentiment;
window.getRecommendations = getRecommendations;
window.conversationMemory = conversationMemory; 